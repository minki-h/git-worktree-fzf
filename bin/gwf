#!/usr/bin/env bash

set -e

VERSION="1.3.6"

# Color codes for output
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
CYAN='\033[0;36m'
BOLD='\033[1m'
DIM='\033[2m'
NC='\033[0m' # No Color

# Check for required dependencies
check_dependencies() {
  if ! command -v git &> /dev/null; then
    echo -e "${RED}Error: git is required but not installed.${NC}" >&2
    exit 1
  fi

  if ! command -v fzf &> /dev/null; then
    echo -e "${RED}Error: fzf is required but not installed.${NC}" >&2
    echo "Install it with: brew install fzf" >&2
    exit 1
  fi
}

# Check if we're in a git repository
check_git_repo() {
  if ! git rev-parse --git-dir > /dev/null 2>&1; then
    echo -e "${RED}Error: Not a git repository${NC}" >&2
    exit 1
  fi
}

# Show help message
show_help() {
  cat << EOF
gwf - Git Worktree with FZF

USAGE:
    gwf [SUBCOMMAND] [ARGS]

SUBCOMMANDS:
    list, ls              List and switch to a worktree (interactive)
    add, new [branch]     Add a new worktree for branch
    delete, rm [-f] [branch..] Delete one or more worktrees
    status                Show status of all worktrees (dirty/clean, ahead/behind)
    info                  Show current worktree information
    prune                 Remove stale worktree entries
    lock [path]           Lock a worktree (prevent accidental deletion)
    unlock [path]         Unlock a worktree
    move [path] [newpath] Move a worktree to a new path
    repair                Repair worktree administrative files
    main                  Switch to main worktree (no fzf)
    init <name> [url]     Initialize a bare repo for worktree workflow
    shell-init            Output shell integration wrapper function
    help, --help          Show this help message
    version               Show version information

EXAMPLES:
    gwf                     # Interactive list and switch
    gwf feature/login       # Switch to worktree for feature/login
    gwf add                 # Create new worktree (interactive)
    gwf add feature/signup  # Create worktree for feature/signup directly
    gwf delete              # Delete worktrees (interactive)
    gwf delete feature/old  # Delete worktree for feature/old directly
    gwf rm fix/bug1 fix/bug2  # Delete multiple worktrees
    gwf status              # See all worktrees status at a glance
    gwf main                # Jump to main worktree
    gwf init myproj         # Init bare repo for worktree workflow

SHELL INTEGRATION:
    Add this to your ~/.bashrc or ~/.zshrc:

    eval "\$(gwf shell-init)"

DEPENDENCIES:
    - git (for git worktree management)
    - fzf (for interactive selection)

EOF
}

# List worktrees and select one to switch to
cmd_list() {
  check_git_repo
  check_dependencies

  local selected_worktree=$(git worktree list | fzf --no-history --prompt="Select worktree: " --height=40% --reverse | awk '{print $1}')

  if [ -n "$selected_worktree" ]; then
    echo "CD:$selected_worktree"
  fi
}

# Switch directly to a worktree by branch name
cmd_switch() {
  local target="$1"
  check_git_repo

  if [[ -z "$target" ]]; then
    # No argument, fall back to interactive list
    cmd_list
    return
  fi

  # Try to find by branch name first
  local selected_worktree
  selected_worktree=$(git worktree list | grep -E "\[$target\]" | awk '{print $1}' | head -1)
  # If not found, try by path (partial match)
  if [[ -z "$selected_worktree" ]]; then
    selected_worktree=$(git worktree list | grep -F "$target" | awk '{print $1}' | head -1)
  fi

  if [[ -n "$selected_worktree" ]]; then
    echo "CD:$selected_worktree"
  else
    echo -e "${RED}Error: No worktree found matching '$target'${NC}" >&2
    exit 1
  fi
}

# Add a new worktree
cmd_add() {
  local target_branch="$1"
  local base_point="${2:-HEAD}"
  check_git_repo

  if [[ -z "$target_branch" ]]; then
    # Interactive mode
    check_dependencies

    # Get list of all branches (local and remote, deduplicated)
    local branches=$(git branch -a | sed 's/.* //g' | sed 's/remotes\/origin\///' | sort -u)

    # Use fzf with --print-query to allow both selection and new branch creation
    local selected=$(echo "$branches" | fzf --no-history --print-query --prompt="Select or type new branch: " --height=40% --reverse)

    # Extract query and selection
    # --print-query outputs: line1=query (what user typed), line2=selection (what was selected)
    local query=$(echo "$selected" | head -n1)
    selected=$(echo "$selected" | tail -n1)

    # Use selection as the target branch
    target_branch="$selected"

    if [[ -z "$target_branch" ]]; then
      echo -e "${YELLOW}No branch selected${NC}" >&2
      exit 0
    fi

    # Ask if user wants a custom directory name
    echo -e "${CYAN}Selected: $target_branch${NC}"
    read -p "Directory name (empty to use branch name): " custom_dir
  fi

  # Get the base directory (parent of main worktree)
  local main_worktree=$(git worktree list | head -1 | awk '{print $1}')
  local base_dir=$(dirname "$main_worktree")

  # Use custom directory name if provided, otherwise use branch name
  local dir_name="${custom_dir:-$target_branch}"
  local target_path="$base_dir/$dir_name"
  local parent_dir=$(dirname "$target_path")
  if [[ ! -d "$parent_dir" ]]; then
    mkdir -p "$parent_dir"
  fi

  # Check if branch exists
  if git rev-parse --verify "$target_branch" >/dev/null 2>&1; then
    echo -e "${GREEN}Checking out existing branch: $target_branch${NC}"
    git worktree add "$target_path" "$target_branch"
  else
    echo -e "${GREEN}Creating new branch: $target_branch from $base_point${NC}"
    git worktree add -b "$target_branch" "$target_path" "$base_point"
  fi

  # Output the path for the shell wrapper to cd into
  if [ -d "$target_path" ]; then
    echo "CD:$target_path"
  else
    echo -e "${RED}Error: Directory $target_path was not created.${NC}" >&2
    exit 1
  fi
}

# Find worktree path by branch name or partial path match
find_worktree() {
  local target="$1"
  local worktree_path
  # Try to find by branch name first
  worktree_path=$(git worktree list | grep -E "\[$target\]" | awk '{print $1}' | head -1)
  # If not found, try by path (partial match)
  if [[ -z "$worktree_path" ]]; then
    worktree_path=$(git worktree list | grep -F "$target" | awk '{print $1}' | head -1)
  fi
  echo "$worktree_path"
}

# Delete one or more worktrees
cmd_delete() {
  check_git_repo

  local selected=""
  local force_flag=""

  # Parse flags
  local args=()
  for arg in "$@"; do
    case "$arg" in
      -f|--force)
        force_flag="--force"
        ;;
      *)
        args+=("$arg")
        ;;
    esac
  done

  if [[ ${#args[@]} -gt 0 ]]; then
    # Direct mode: arguments provided
    for target in "${args[@]}"; do
      local worktree_path
      worktree_path=$(find_worktree "$target")
      if [[ -n "$worktree_path" ]]; then
        selected+="$worktree_path"$'\n'
      else
        echo -e "${RED}Warning: No worktree found matching '$target'${NC}" >&2
      fi
    done
    selected="${selected%$'\n'}"  # Remove trailing newline
  else
    # Interactive mode
    check_dependencies
    selected=$(git worktree list | fzf --no-history --multi --prompt="Delete worktree(s): " --height=40% --reverse | awk '{print $1}')
  fi

  if [[ -z "$selected" ]]; then
    echo -e "${YELLOW}No worktrees selected${NC}" >&2
    exit 0
  fi

  # Confirm deletion
  echo -e "${YELLOW}About to delete:${NC}"
  echo "$selected"
  if [[ -n "$force_flag" ]]; then
    echo -e "${RED}(force mode)${NC}"
  fi
  read -p "Continue? [y/N] " -r
  if [[ $REPLY =~ ^[Yy]$ ]]; then
    local failed=0
    local removed_branches=()
    while IFS= read -r worktree; do
      [[ -z "$worktree" ]] && continue
      # Get branch name before removing worktree
      local branch_name=$(git worktree list | grep "^$worktree " | sed 's/.*\[\(.*\)\].*/\1/')
      echo -e "${GREEN}Removing: $worktree${NC}"
      if git worktree remove $force_flag "$worktree"; then
        # Track successfully removed branches (skip detached HEAD)
        if [[ -n "$branch_name" ]] && [[ "$branch_name" != "detached" ]]; then
          removed_branches+=("$branch_name")
        fi
      else
        echo -e "${RED}Failed to remove: $worktree${NC}" >&2
        ((failed++)) || true
      fi
    done <<< "$selected"

    # Ask to delete branches
    if [[ ${#removed_branches[@]} -gt 0 ]]; then
      echo ""
      echo -e "${YELLOW}Delete branches as well?${NC}"
      for branch in "${removed_branches[@]}"; do
        echo "  $branch"
      done
      read -p "Delete these branches? [y/N] " -r
      if [[ $REPLY =~ ^[Yy]$ ]]; then
        for branch in "${removed_branches[@]}"; do
          if git branch -d "$branch" 2>/dev/null; then
            echo -e "${GREEN}Deleted branch: $branch${NC}"
          elif git branch -D "$branch" 2>/dev/null; then
            echo -e "${YELLOW}Force deleted branch: $branch${NC}"
          else
            echo -e "${RED}Failed to delete branch: $branch${NC}" >&2
          fi
        done
      fi
    fi

    if [[ $failed -eq 0 ]]; then
      echo -e "${GREEN}Done!${NC}"
    else
      echo -e "${YELLOW}Completed with $failed failure(s)${NC}"
    fi
  else
    echo -e "${YELLOW}Cancelled${NC}"
  fi
}

# Show status of all worktrees
cmd_status() {
  check_git_repo

  echo -e "${BOLD}Worktree Status${NC}"
  echo -e "${DIM}â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€${NC}"

  git worktree list --porcelain | while read -r line; do
    if [[ "$line" == worktree* ]]; then
      local path="${line#worktree }"
      local branch=""
      local head=""
      local locked=""
      local prunable=""

      # Read subsequent lines for this worktree
      while read -r subline && [[ -n "$subline" ]]; do
        case "$subline" in
          "branch refs/heads/"*) branch="${subline#branch refs/heads/}" ;;
          "HEAD "*) head="${subline#HEAD }" ;;
          "locked"*) locked="yes" ;;
          "prunable"*) prunable="yes" ;;
        esac
      done

      # Check dirty status and ahead/behind
      local status_info=""
      local dirty=""
      local ahead_behind=""

      if [[ -d "$path" ]]; then
        # Check for uncommitted changes
        if [[ -n "$(git -C "$path" status --porcelain 2>/dev/null)" ]]; then
          dirty="${YELLOW}â—${NC}"
        else
          dirty="${GREEN}â—${NC}"
        fi

        # Check ahead/behind
        if [[ -n "$branch" ]]; then
          local upstream=$(git -C "$path" rev-parse --abbrev-ref "@{upstream}" 2>/dev/null)
          if [[ -n "$upstream" ]]; then
            local ahead=$(git -C "$path" rev-list --count "@{upstream}..HEAD" 2>/dev/null || echo "0")
            local behind=$(git -C "$path" rev-list --count "HEAD..@{upstream}" 2>/dev/null || echo "0")
            if [[ "$ahead" -gt 0 && "$behind" -gt 0 ]]; then
              ahead_behind="${CYAN}â†‘${ahead}â†“${behind}${NC}"
            elif [[ "$ahead" -gt 0 ]]; then
              ahead_behind="${GREEN}â†‘${ahead}${NC}"
            elif [[ "$behind" -gt 0 ]]; then
              ahead_behind="${YELLOW}â†“${behind}${NC}"
            fi
          fi
        fi
      else
        dirty="${RED}âœ—${NC}"
      fi

      # Build status line
      local lock_icon=""
      if [[ -n "$locked" ]]; then
        lock_icon=" ${YELLOW}ðŸ”’${NC}"
      fi

      local branch_display="${branch:-detached:${head:0:7}}"

      printf "%b %b %-30s %b %s%b\n" "$dirty" "$ahead_behind" "$branch_display" "${DIM}${path}${NC}" "$lock_icon"
    fi
  done

  echo -e "${DIM}â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€${NC}"
  echo -e "${GREEN}â—${NC} clean  ${YELLOW}â—${NC} dirty  ${RED}âœ—${NC} missing  ${GREEN}â†‘${NC} ahead  ${YELLOW}â†“${NC} behind"
}

# Show info about current worktree
cmd_info() {
  check_git_repo

  local toplevel=$(git rev-parse --show-toplevel 2>/dev/null)
  local branch=$(git rev-parse --abbrev-ref HEAD 2>/dev/null)
  local commit=$(git rev-parse --short HEAD 2>/dev/null)
  local commit_msg=$(git log -1 --format=%s 2>/dev/null)
  local commit_date=$(git log -1 --format=%cr 2>/dev/null)

  # Check if current directory is a worktree
  local git_common_dir=$(git rev-parse --git-common-dir 2>/dev/null)
  local git_dir=$(git rev-parse --git-dir 2>/dev/null)
  local is_worktree="no"
  if [[ "$git_common_dir" != "$git_dir" ]]; then
    is_worktree="yes"
  fi

  # Check lock status
  local locked="no"
  local lock_reason=""
  if [[ -f "$git_dir/locked" ]]; then
    locked="yes"
    lock_reason=$(cat "$git_dir/locked" 2>/dev/null)
  fi

  echo -e "${BOLD}Current Worktree Info${NC}"
  echo -e "${DIM}â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€${NC}"
  echo -e "${CYAN}Path:${NC}      $toplevel"
  echo -e "${CYAN}Branch:${NC}    $branch"
  echo -e "${CYAN}Commit:${NC}    $commit - $commit_msg"
  echo -e "${CYAN}Date:${NC}      $commit_date"
  echo -e "${CYAN}Worktree:${NC}  $is_worktree"
  if [[ "$locked" == "yes" ]]; then
    echo -e "${CYAN}Locked:${NC}    ${YELLOW}yes${NC}"
    if [[ -n "$lock_reason" ]]; then
      echo -e "${CYAN}Reason:${NC}    $lock_reason"
    fi
  else
    echo -e "${CYAN}Locked:${NC}    no"
  fi

  # Show status
  local changes=$(git status --porcelain 2>/dev/null | wc -l | tr -d ' ')
  if [[ "$changes" -gt 0 ]]; then
    echo -e "${CYAN}Status:${NC}    ${YELLOW}$changes uncommitted change(s)${NC}"
  else
    echo -e "${CYAN}Status:${NC}    ${GREEN}clean${NC}"
  fi
}

# Prune stale worktree entries
cmd_prune() {
  check_git_repo

  # Show what would be pruned
  local stale=$(git worktree list --porcelain | grep -A1 "^prunable" 2>/dev/null || true)

  if [[ -z "$stale" ]]; then
    echo -e "${GREEN}No stale worktrees to prune.${NC}"
    return 0
  fi

  echo -e "${YELLOW}The following stale worktrees will be pruned:${NC}"
  while read -r line; do
    local path
    path=$(echo "$line" | awk '{print $1}')
    if [[ ! -d "$path" ]]; then
      echo -e "  ${RED}$line${NC}"
    fi
  done < <(git worktree list)

  read -p "Continue with prune? [y/N] " -r
  if [[ $REPLY =~ ^[Yy]$ ]]; then
    git worktree prune -v
    echo -e "${GREEN}Done!${NC}"
  else
    echo -e "${YELLOW}Cancelled${NC}"
  fi
}

# Lock a worktree
cmd_lock() {
  check_git_repo
  check_dependencies

  local selected=$(git worktree list | fzf --no-history --prompt="Lock worktree: " --height=40% --reverse | awk '{print $1}')

  if [[ -z "$selected" ]]; then
    echo -e "${YELLOW}No worktree selected${NC}" >&2
    exit 0
  fi

  # Check if already locked
  local git_dir=$(git worktree list --porcelain | grep -A10 "^worktree $selected$" | grep "^gitdir" | head -1 | sed 's/gitdir //')
  if [[ -z "$git_dir" ]]; then
    # Fallback: try to find via path
    if [[ -f "$selected/.git" ]]; then
      git_dir=$(cat "$selected/.git" | sed 's/gitdir: //')
    fi
  fi

  if [[ -f "$git_dir/locked" ]] 2>/dev/null; then
    echo -e "${YELLOW}Worktree is already locked${NC}"
    return 0
  fi

  read -p "Lock reason (optional): " reason

  if [[ -n "$reason" ]]; then
    git worktree lock --reason "$reason" "$selected"
  else
    git worktree lock "$selected"
  fi

  echo -e "${GREEN}Locked: $selected${NC}"
}

# Unlock a worktree
cmd_unlock() {
  check_git_repo
  check_dependencies

  # Filter to only show locked worktrees
  local locked_worktrees=""
  while read -r line; do
    local path=$(echo "$line" | awk '{print $1}')
    local git_dir=""
    if [[ -f "$path/.git" ]]; then
      git_dir=$(cat "$path/.git" 2>/dev/null | sed 's/gitdir: //')
    fi
    if [[ -f "$git_dir/locked" ]] 2>/dev/null; then
      locked_worktrees+="$line"$'\n'
    fi
  done < <(git worktree list)

  if [[ -z "${locked_worktrees// }" ]]; then
    echo -e "${GREEN}No locked worktrees found.${NC}"
    return 0
  fi

  local selected=$(echo -n "$locked_worktrees" | fzf --no-history --prompt="Unlock worktree: " --height=40% --reverse | awk '{print $1}')

  if [[ -z "$selected" ]]; then
    echo -e "${YELLOW}No worktree selected${NC}" >&2
    exit 0
  fi

  git worktree unlock "$selected"
  echo -e "${GREEN}Unlocked: $selected${NC}"
}

# Move a worktree to a new path
cmd_move() {
  check_git_repo
  check_dependencies

  local selected=$(git worktree list | fzf --no-history --prompt="Move worktree: " --height=40% --reverse | awk '{print $1}')

  if [[ -z "$selected" ]]; then
    echo -e "${YELLOW}No worktree selected${NC}" >&2
    exit 0
  fi

  # Don't allow moving the main worktree
  local main_worktree=$(git worktree list | head -1 | awk '{print $1}')
  if [[ "$selected" == "$main_worktree" ]]; then
    echo -e "${RED}Error: Cannot move the main worktree${NC}" >&2
    exit 1
  fi

  echo -e "Selected: ${CYAN}$selected${NC}"
  read -p "New path: " new_path

  if [[ -z "$new_path" ]]; then
    echo -e "${YELLOW}No path specified${NC}" >&2
    exit 0
  fi

  # Expand ~ to home directory
  new_path="${new_path/#\~/$HOME}"

  # Create parent directory if it doesn't exist
  local parent_dir=$(dirname "$new_path")
  if [[ ! -d "$parent_dir" ]]; then
    mkdir -p "$parent_dir"
  fi

  git worktree move "$selected" "$new_path"
  echo -e "${GREEN}Moved to: $new_path${NC}"
}

# Repair worktrees
cmd_repair() {
  check_git_repo

  echo -e "${CYAN}Repairing worktrees...${NC}"
  git worktree repair
  echo -e "${GREEN}Done!${NC}"
}

# Jump to main/master worktree
cmd_main() {
  check_git_repo

  # Get the main worktree (first one in the list, which is always the main repository)
  local main_worktree=$(git worktree list | head -1 | awk '{print $1}')

  if [[ -n "$main_worktree" ]]; then
    echo "CD:$main_worktree"
  else
    echo -e "${RED}Error: Could not find main worktree${NC}" >&2
    exit 1
  fi
}

# Initialize a bare repo for worktree workflow
cmd_init() {
  local repo_name="$1"

  if [[ -z "$repo_name" ]]; then
    echo -e "${RED}Error: Repository name required${NC}" >&2
    echo "Usage: gwf init <repo-name> [remote-url]" >&2
    exit 1
  fi

  # Prevent / in repo_name to avoid nested directories
  if [[ "$repo_name" == */* ]]; then
    echo -e "${RED}Error: Repository name cannot contain '/'${NC}" >&2
    exit 1
  fi

  local remote_url="$2"
  local base_dir="$repo_name"
  local bare_dir="$repo_name/.bare"

  # Check if directory already exists
  if [[ -d "$base_dir" ]]; then
    echo -e "${RED}Error: Directory '$base_dir' already exists${NC}" >&2
    exit 1
  fi

  # Create base directory
  mkdir -p "$base_dir"

  echo -e "${CYAN}Initializing bare repository: $bare_dir${NC}"

  if [[ -n "$remote_url" ]]; then
    # Clone as bare repo
    git clone --bare "$remote_url" "$bare_dir"
    echo -e "${GREEN}Cloned bare repository from: $remote_url${NC}"

    # Configure remote fetch for all branches
    git -C "$bare_dir" config remote.origin.fetch "+refs/heads/*:refs/remotes/origin/*"
    git -C "$bare_dir" fetch origin
  else
    # Create new bare repo
    git init --bare "$bare_dir"
    echo -e "${GREEN}Created empty bare repository${NC}"
  fi

  # Determine default branch from bare repo's HEAD
  local default_branch=""
  if [[ -n "$remote_url" ]]; then
    # Bare repo's HEAD points to the default branch after clone
    default_branch=$(git -C "$bare_dir" symbolic-ref HEAD 2>/dev/null | sed 's@^refs/heads/@@')
  fi

  # Fallback to main if not detected
  if [[ -z "$default_branch" ]]; then
    default_branch="main"
  fi

  # Create main worktree with absolute path (required for git -C)
  if [[ -n "$default_branch" ]]; then
    local worktree_path
    worktree_path="$(pwd)/$base_dir/$default_branch"
    echo -e "${CYAN}Creating main worktree for branch: $default_branch${NC}"
    git -C "$bare_dir" worktree add "$worktree_path" "$default_branch" 2>/dev/null || \
      git -C "$bare_dir" worktree add -b "$default_branch" "$worktree_path"
  fi

  echo ""
  echo -e "${GREEN}âœ“ Bare repository setup complete!${NC}"
  echo ""
  echo -e "${BOLD}Directory structure:${NC}"
  echo -e "  ${CYAN}$base_dir/${NC}"
  echo -e "    ${CYAN}.bare/${NC}           <- bare repo (git data)"
  if [[ -n "$default_branch" ]]; then
    echo -e "    ${CYAN}$default_branch/${NC}           <- main worktree"
  fi
  echo ""
  echo -e "${BOLD}Next steps:${NC}"
  if [[ -n "$default_branch" ]]; then
    echo -e "  cd $base_dir/$default_branch"
  else
    echo -e "  cd $base_dir"
  fi
  echo -e "  gwf add              # Add more worktrees"
  echo ""

  # Output path to cd into
  if [[ -n "$default_branch" ]] && [[ -d "$base_dir/$default_branch" ]]; then
    echo "CD:$base_dir/$default_branch"
  elif [[ -d "$base_dir" ]]; then
    echo "CD:$base_dir"
  fi
}

# Output shell integration wrapper function
cmd_shell_init() {
  cat <<'EOF'
gwf() {
  local output=$(command gwf "$@")
  local last_line="${output##*$'\n'}"
  if [[ "$last_line" == CD:* ]]; then
    echo "${output%$'\n'$last_line}"
    cd "${last_line#CD:}"
  else
    echo "$output"
  fi
}
EOF
}

# Show version
show_version() {
  echo "gwf version $VERSION"
}

# Main entry point
main() {
  local subcommand="${1:-list}"
  shift 2>/dev/null || true

  case "$subcommand" in
    list|ls)
      cmd_list
      ;;
    add|new)
      cmd_add "$@"
      ;;
    delete|rm)
      cmd_delete "$@"
      ;;
    status)
      cmd_status
      ;;
    info)
      cmd_info
      ;;
    prune)
      cmd_prune
      ;;
    lock)
      cmd_lock
      ;;
    unlock)
      cmd_unlock
      ;;
    move)
      cmd_move
      ;;
    repair)
      cmd_repair
      ;;
    main)
      cmd_main
      ;;
    init)
      cmd_init "$@"
      ;;
    shell-init)
      cmd_shell_init
      ;;
    help|--help|-h)
      show_help
      ;;
    version|--version|-v)
      show_version
      ;;
    *)
      # Try to switch to worktree by branch name
      cmd_switch "$subcommand"
      ;;
  esac
}

main "$@"
