#!/usr/bin/env bash

set -e

VERSION="1.1.0"

# Color codes for output
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
CYAN='\033[0;36m'
BOLD='\033[1m'
DIM='\033[2m'
NC='\033[0m' # No Color

# Check for required dependencies
check_dependencies() {
  if ! command -v git &> /dev/null; then
    echo -e "${RED}Error: git is required but not installed.${NC}" >&2
    exit 1
  fi

  if ! command -v fzf &> /dev/null; then
    echo -e "${RED}Error: fzf is required but not installed.${NC}" >&2
    echo "Install it with: brew install fzf" >&2
    exit 1
  fi
}

# Check if we're in a git repository
check_git_repo() {
  if ! git rev-parse --git-dir > /dev/null 2>&1; then
    echo -e "${RED}Error: Not a git repository${NC}" >&2
    exit 1
  fi
}

# Show help message
show_help() {
  cat << EOF
gwf - Git Worktree with FZF

USAGE:
    gwf [SUBCOMMAND]

SUBCOMMANDS:
    list, ls        List and switch to a worktree (default)
    add, new        Add a new worktree
    delete, rm      Delete one or more worktrees
    status          Show status of all worktrees (dirty/clean, ahead/behind)
    info            Show current worktree information
    prune           Remove stale worktree entries
    lock            Lock a worktree (prevent accidental deletion)
    unlock          Unlock a worktree
    move            Move a worktree to a new path
    repair          Repair worktree administrative files
    main            Switch to main worktree (no fzf)
    init            Initialize a bare repo for worktree workflow
    help, --help    Show this help message
    version         Show version information

EXAMPLES:
    gwf             # Interactive list and switch
    gwf add         # Create new worktree
    gwf delete      # Delete worktrees
    gwf status      # See all worktrees status at a glance
    gwf main        # Jump to main worktree
    gwf init myproj # Init bare repo for worktree workflow

SHELL INTEGRATION:
    The 'list' command outputs a path prefixed with 'CD:' which can be
    captured by a shell wrapper function to actually change directory.

    Add this to your ~/.bashrc or ~/.zshrc:

    gwf() {
      local result=\$(command gwf "\$@")
      if [[ "\$result" == CD:* ]]; then
        cd "\${result#CD:}"
      else
        echo "\$result"
      fi
    }

DEPENDENCIES:
    - git (for git worktree management)
    - fzf (for interactive selection)

EOF
}

# List worktrees and select one to switch to
cmd_list() {
  check_git_repo
  check_dependencies

  local selected_worktree=$(git worktree list | fzf --prompt="Select worktree: " --height=40% --reverse | awk '{print $1}')

  if [ -n "$selected_worktree" ]; then
    echo "CD:$selected_worktree"
  fi
}

# Add a new worktree
cmd_add() {
  check_git_repo
  check_dependencies

  # Get list of all branches (local and remote, deduplicated)
  local branches=$(git branch -a | sed 's/.* //g' | sed 's/remotes\/origin\///' | sort -u)

  # Use fzf with --print-query to allow both selection and new branch creation
  local selected=$(echo "$branches" | fzf --print-query --prompt="Select or type new branch: " --height=40% --reverse)

  # Extract query and selection
  local query=$(echo "$selected" | head -n1)
  selected=$(echo "$selected" | tail -n1)

  # Use query if provided, otherwise use selection
  local target_branch=${query:-$selected}

  if [ -z "$target_branch" ]; then
    echo -e "${YELLOW}No branch selected${NC}" >&2
    exit 0
  fi

  # Convert branch name to folder name (replace / with _)
  local folder_name=$(echo "$target_branch" | sed 's/\//_/g')
  local target_path="../$folder_name"

  # Check if branch exists
  if git rev-parse --verify "$target_branch" >/dev/null 2>&1; then
    echo -e "${GREEN}Checking out existing branch: $target_branch${NC}"
    git worktree add "$target_path" "$target_branch"
  else
    # Determine base point for new branch
    local base_point=$selected
    if [ "$query" = "$selected" ] || [ -z "$selected" ]; then
      base_point="HEAD"
    fi

    echo -e "${GREEN}Creating new branch: $target_branch from $base_point${NC}"
    git worktree add -b "$target_branch" "$target_path" "$base_point"
  fi

  # Output the path for the shell wrapper to cd into
  if [ -d "$target_path" ]; then
    echo "CD:$target_path"
  else
    echo -e "${RED}Error: Directory $target_path was not created.${NC}" >&2
    exit 1
  fi
}

# Delete one or more worktrees
cmd_delete() {
  check_git_repo
  check_dependencies

  local selected=$(git worktree list | fzf --multi --prompt="Delete worktree(s): " --height=40% --reverse | awk '{print $1}')

  if [ -z "$selected" ]; then
    echo -e "${YELLOW}No worktrees selected${NC}" >&2
    exit 0
  fi

  # Confirm deletion
  echo -e "${YELLOW}About to delete:${NC}"
  echo "$selected"
  read -p "Continue? [y/N] " -n 1 -r
  echo

  if [[ $REPLY =~ ^[Yy]$ ]]; then
    echo "$selected" | while IFS= read -r worktree; do
      echo -e "${GREEN}Removing: $worktree${NC}"
      git worktree remove "$worktree"
    done
    echo -e "${GREEN}Done!${NC}"
  else
    echo -e "${YELLOW}Cancelled${NC}"
  fi
}

# Show status of all worktrees
cmd_status() {
  check_git_repo

  echo -e "${BOLD}Worktree Status${NC}"
  echo -e "${DIM}â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€${NC}"

  git worktree list --porcelain | while read -r line; do
    if [[ "$line" == worktree* ]]; then
      local path="${line#worktree }"
      local branch=""
      local head=""
      local locked=""
      local prunable=""

      # Read subsequent lines for this worktree
      while read -r subline && [[ -n "$subline" ]]; do
        case "$subline" in
          "branch refs/heads/"*) branch="${subline#branch refs/heads/}" ;;
          "HEAD "*) head="${subline#HEAD }" ;;
          "locked"*) locked="yes" ;;
          "prunable"*) prunable="yes" ;;
        esac
      done

      # Check dirty status and ahead/behind
      local status_info=""
      local dirty=""
      local ahead_behind=""

      if [[ -d "$path" ]]; then
        # Check for uncommitted changes
        if [[ -n "$(git -C "$path" status --porcelain 2>/dev/null)" ]]; then
          dirty="${YELLOW}â—${NC}"
        else
          dirty="${GREEN}â—${NC}"
        fi

        # Check ahead/behind
        if [[ -n "$branch" ]]; then
          local upstream=$(git -C "$path" rev-parse --abbrev-ref "@{upstream}" 2>/dev/null)
          if [[ -n "$upstream" ]]; then
            local ahead=$(git -C "$path" rev-list --count "@{upstream}..HEAD" 2>/dev/null || echo "0")
            local behind=$(git -C "$path" rev-list --count "HEAD..@{upstream}" 2>/dev/null || echo "0")
            if [[ "$ahead" -gt 0 && "$behind" -gt 0 ]]; then
              ahead_behind="${CYAN}â†‘${ahead}â†“${behind}${NC}"
            elif [[ "$ahead" -gt 0 ]]; then
              ahead_behind="${GREEN}â†‘${ahead}${NC}"
            elif [[ "$behind" -gt 0 ]]; then
              ahead_behind="${YELLOW}â†“${behind}${NC}"
            fi
          fi
        fi
      else
        dirty="${RED}âœ—${NC}"
      fi

      # Build status line
      local lock_icon=""
      if [[ -n "$locked" ]]; then
        lock_icon=" ${YELLOW}ðŸ”’${NC}"
      fi

      local branch_display="${branch:-detached:${head:0:7}}"

      printf "%b %b %-30s %b %s%b\n" "$dirty" "$ahead_behind" "$branch_display" "${DIM}${path}${NC}" "$lock_icon"
    fi
  done

  echo -e "${DIM}â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€${NC}"
  echo -e "${GREEN}â—${NC} clean  ${YELLOW}â—${NC} dirty  ${RED}âœ—${NC} missing  ${GREEN}â†‘${NC} ahead  ${YELLOW}â†“${NC} behind"
}

# Show info about current worktree
cmd_info() {
  check_git_repo

  local toplevel=$(git rev-parse --show-toplevel 2>/dev/null)
  local branch=$(git rev-parse --abbrev-ref HEAD 2>/dev/null)
  local commit=$(git rev-parse --short HEAD 2>/dev/null)
  local commit_msg=$(git log -1 --format=%s 2>/dev/null)
  local commit_date=$(git log -1 --format=%cr 2>/dev/null)

  # Check if current directory is a worktree
  local git_common_dir=$(git rev-parse --git-common-dir 2>/dev/null)
  local git_dir=$(git rev-parse --git-dir 2>/dev/null)
  local is_worktree="no"
  if [[ "$git_common_dir" != "$git_dir" ]]; then
    is_worktree="yes"
  fi

  # Check lock status
  local locked="no"
  local lock_reason=""
  if [[ -f "$git_dir/locked" ]]; then
    locked="yes"
    lock_reason=$(cat "$git_dir/locked" 2>/dev/null)
  fi

  echo -e "${BOLD}Current Worktree Info${NC}"
  echo -e "${DIM}â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€${NC}"
  echo -e "${CYAN}Path:${NC}      $toplevel"
  echo -e "${CYAN}Branch:${NC}    $branch"
  echo -e "${CYAN}Commit:${NC}    $commit - $commit_msg"
  echo -e "${CYAN}Date:${NC}      $commit_date"
  echo -e "${CYAN}Worktree:${NC}  $is_worktree"
  if [[ "$locked" == "yes" ]]; then
    echo -e "${CYAN}Locked:${NC}    ${YELLOW}yes${NC}"
    if [[ -n "$lock_reason" ]]; then
      echo -e "${CYAN}Reason:${NC}    $lock_reason"
    fi
  else
    echo -e "${CYAN}Locked:${NC}    no"
  fi

  # Show status
  local changes=$(git status --porcelain 2>/dev/null | wc -l | tr -d ' ')
  if [[ "$changes" -gt 0 ]]; then
    echo -e "${CYAN}Status:${NC}    ${YELLOW}$changes uncommitted change(s)${NC}"
  else
    echo -e "${CYAN}Status:${NC}    ${GREEN}clean${NC}"
  fi
}

# Prune stale worktree entries
cmd_prune() {
  check_git_repo

  # Show what would be pruned
  local stale=$(git worktree list --porcelain | grep -A1 "^prunable" 2>/dev/null || true)

  if [[ -z "$stale" ]]; then
    echo -e "${GREEN}No stale worktrees to prune.${NC}"
    return 0
  fi

  echo -e "${YELLOW}The following stale worktrees will be pruned:${NC}"
  git worktree list | while read -r line; do
    local path=$(echo "$line" | awk '{print $1}')
    if [[ ! -d "$path" ]]; then
      echo -e "  ${RED}$line${NC}"
    fi
  done

  read -p "Continue with prune? [y/N] " -n 1 -r
  echo

  if [[ $REPLY =~ ^[Yy]$ ]]; then
    git worktree prune -v
    echo -e "${GREEN}Done!${NC}"
  else
    echo -e "${YELLOW}Cancelled${NC}"
  fi
}

# Lock a worktree
cmd_lock() {
  check_git_repo
  check_dependencies

  local selected=$(git worktree list | fzf --prompt="Lock worktree: " --height=40% --reverse | awk '{print $1}')

  if [[ -z "$selected" ]]; then
    echo -e "${YELLOW}No worktree selected${NC}" >&2
    exit 0
  fi

  # Check if already locked
  local git_dir=$(git worktree list --porcelain | grep -A10 "^worktree $selected$" | grep "^gitdir" | head -1 | sed 's/gitdir //')
  if [[ -z "$git_dir" ]]; then
    # Fallback: try to find via path
    if [[ -f "$selected/.git" ]]; then
      git_dir=$(cat "$selected/.git" | sed 's/gitdir: //')
    fi
  fi

  if [[ -f "$git_dir/locked" ]] 2>/dev/null; then
    echo -e "${YELLOW}Worktree is already locked${NC}"
    return 0
  fi

  read -p "Lock reason (optional): " reason

  if [[ -n "$reason" ]]; then
    git worktree lock --reason "$reason" "$selected"
  else
    git worktree lock "$selected"
  fi

  echo -e "${GREEN}Locked: $selected${NC}"
}

# Unlock a worktree
cmd_unlock() {
  check_git_repo
  check_dependencies

  # Filter to only show locked worktrees
  local locked_worktrees=""
  while read -r line; do
    local path=$(echo "$line" | awk '{print $1}')
    local git_dir=""
    if [[ -f "$path/.git" ]]; then
      git_dir=$(cat "$path/.git" 2>/dev/null | sed 's/gitdir: //')
    fi
    if [[ -f "$git_dir/locked" ]] 2>/dev/null; then
      locked_worktrees+="$line"$'\n'
    fi
  done < <(git worktree list)

  if [[ -z "${locked_worktrees// }" ]]; then
    echo -e "${GREEN}No locked worktrees found.${NC}"
    return 0
  fi

  local selected=$(echo -n "$locked_worktrees" | fzf --prompt="Unlock worktree: " --height=40% --reverse | awk '{print $1}')

  if [[ -z "$selected" ]]; then
    echo -e "${YELLOW}No worktree selected${NC}" >&2
    exit 0
  fi

  git worktree unlock "$selected"
  echo -e "${GREEN}Unlocked: $selected${NC}"
}

# Move a worktree to a new path
cmd_move() {
  check_git_repo
  check_dependencies

  local selected=$(git worktree list | fzf --prompt="Move worktree: " --height=40% --reverse | awk '{print $1}')

  if [[ -z "$selected" ]]; then
    echo -e "${YELLOW}No worktree selected${NC}" >&2
    exit 0
  fi

  # Don't allow moving the main worktree
  local main_worktree=$(git worktree list | head -1 | awk '{print $1}')
  if [[ "$selected" == "$main_worktree" ]]; then
    echo -e "${RED}Error: Cannot move the main worktree${NC}" >&2
    exit 1
  fi

  echo -e "Selected: ${CYAN}$selected${NC}"
  read -p "New path: " new_path

  if [[ -z "$new_path" ]]; then
    echo -e "${YELLOW}No path specified${NC}" >&2
    exit 0
  fi

  # Expand ~ to home directory
  new_path="${new_path/#\~/$HOME}"

  git worktree move "$selected" "$new_path"
  echo -e "${GREEN}Moved to: $new_path${NC}"
}

# Repair worktrees
cmd_repair() {
  check_git_repo

  echo -e "${CYAN}Repairing worktrees...${NC}"
  git worktree repair
  echo -e "${GREEN}Done!${NC}"
}

# Jump to main/master worktree
cmd_main() {
  check_git_repo

  # Get the main worktree (first one in the list, which is always the main repository)
  local main_worktree=$(git worktree list | head -1 | awk '{print $1}')

  if [[ -n "$main_worktree" ]]; then
    echo "CD:$main_worktree"
  else
    echo -e "${RED}Error: Could not find main worktree${NC}" >&2
    exit 1
  fi
}

# Initialize a bare repo for worktree workflow
cmd_init() {
  local repo_name="$1"

  if [[ -z "$repo_name" ]]; then
    echo -e "${RED}Error: Repository name required${NC}" >&2
    echo "Usage: gwf init <repo-name> [remote-url]" >&2
    exit 1
  fi

  local remote_url="$2"
  local bare_dir="${repo_name}.git"

  # Check if directory already exists
  if [[ -d "$bare_dir" ]]; then
    echo -e "${RED}Error: Directory '$bare_dir' already exists${NC}" >&2
    exit 1
  fi

  echo -e "${CYAN}Initializing bare repository: $bare_dir${NC}"

  if [[ -n "$remote_url" ]]; then
    # Clone as bare repo
    git clone --bare "$remote_url" "$bare_dir"
    echo -e "${GREEN}Cloned bare repository from: $remote_url${NC}"

    # Configure remote fetch for all branches
    git -C "$bare_dir" config remote.origin.fetch "+refs/heads/*:refs/remotes/origin/*"
    git -C "$bare_dir" fetch origin
  else
    # Create new bare repo
    git init --bare "$bare_dir"
    echo -e "${GREEN}Created empty bare repository${NC}"
  fi

  # Create main worktree
  cd "$bare_dir"

  # Determine default branch
  local default_branch=""
  if [[ -n "$remote_url" ]]; then
    default_branch=$(git symbolic-ref refs/remotes/origin/HEAD 2>/dev/null | sed 's@^refs/remotes/origin/@@')
    if [[ -z "$default_branch" ]]; then
      # Try common default branch names
      if git show-ref --verify --quiet refs/heads/main 2>/dev/null || git show-ref --verify --quiet refs/remotes/origin/main 2>/dev/null; then
        default_branch="main"
      elif git show-ref --verify --quiet refs/heads/master 2>/dev/null || git show-ref --verify --quiet refs/remotes/origin/master 2>/dev/null; then
        default_branch="master"
      fi
    fi
  else
    default_branch="main"
  fi

  if [[ -n "$default_branch" ]]; then
    echo -e "${CYAN}Creating main worktree for branch: $default_branch${NC}"
    git worktree add "../$repo_name" "$default_branch" 2>/dev/null || git worktree add -b "$default_branch" "../$repo_name"
  fi

  cd ..

  echo ""
  echo -e "${GREEN}âœ“ Bare repository setup complete!${NC}"
  echo ""
  echo -e "${BOLD}Directory structure:${NC}"
  echo -e "  ${CYAN}$bare_dir/${NC}          <- bare repo (git data)"
  if [[ -n "$default_branch" ]]; then
    echo -e "  ${CYAN}$repo_name/${NC}           <- main worktree ($default_branch)"
  fi
  echo ""
  echo -e "${BOLD}Next steps:${NC}"
  echo -e "  cd $repo_name"
  echo -e "  gwf add              # Add more worktrees"
  echo ""

  # Output path to cd into
  if [[ -d "$repo_name" ]]; then
    echo "CD:$repo_name"
  fi
}

# Show version
show_version() {
  echo "gwf version $VERSION"
}

# Main entry point
main() {
  local subcommand="${1:-list}"
  shift 2>/dev/null || true

  case "$subcommand" in
    list|ls)
      cmd_list
      ;;
    add|new)
      cmd_add
      ;;
    delete|rm)
      cmd_delete
      ;;
    status)
      cmd_status
      ;;
    info)
      cmd_info
      ;;
    prune)
      cmd_prune
      ;;
    lock)
      cmd_lock
      ;;
    unlock)
      cmd_unlock
      ;;
    move)
      cmd_move
      ;;
    repair)
      cmd_repair
      ;;
    main)
      cmd_main
      ;;
    init)
      cmd_init "$@"
      ;;
    help|--help|-h)
      show_help
      ;;
    version|--version|-v)
      show_version
      ;;
    *)
      echo -e "${RED}Error: Unknown subcommand '$subcommand'${NC}" >&2
      echo "Run 'gwf help' for usage information." >&2
      exit 1
      ;;
  esac
}

main "$@"
